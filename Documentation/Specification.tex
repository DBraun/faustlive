
\documentclass[a4paper]{article}
\usepackage{pslatex}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\setlength\parskip{\medskipamount}
\setlength\parindent{0pt}
\usepackage{graphicx}
\usepackage{amssymb}
%\usepackage{hyperref}

\usepackage{multicol}

\makeatletter

\providecommand{\boldsymbol}[1]{\mbox{\boldmath $#1$}}
\newcommand{\ASL}			{ASL}
\newcommand{\OSC}[1]		{\texttt{#1}}
\newcommand{\lra}			{$\leftrightarrow$}
\newcommand{\seg}[1]		{Seg(#1)}

\setlength{\parskip}{1mm}

\makeatother

\begin{document}

\title{FaustLive - Specification \\ v.1.2}

\author{Grame, Centre National de Cr√©ation Musicale\\
{\small <research@grame.fr>} \\
\vspace{2mm}
[ANR-12-CORD- 0009] and [ANR-13-BS02-0008]
}

\maketitle

\topskip0pt

\vspace{\fill}

%==================================================================================================
FaustLive is an advanced self-contained prototyping environment for the Faust programming language with an ultra-short edit-compile-run cycle. Thanks to its fully embedded compilation chain, FaustLive is simple to install and doesn't require any external compiler, development toolchain or SDK to run. FaustLive is the ideal tool for fast prototyping. Faust programs can be compiled and run on the fly by simple drag and drop. They can even be edited and recompiled while running without sound interruption or Jack disconnection. \\
\\
FaustLive is based on QT. Most classes are a reimplementation of QObjects. 
To know more about these base-objects, see QT documentation : http://qt-project.org/doc/qt-5/classes.html
\vspace{\fill}

\newpage
\tableofcontents

\newpage
\section{General Considerations}

The structure of FaustLive is based on three main classes : FLApp, FLWindow and FLSessionManager.

\begin{itemize}
\item FLApp is a reimplementation of QApplication. Its role is to be a communication center between the menus, dialogs, windows, etc. 

\item FLWindow reimplements QMainWindow. Its role is to contain the DSP, its interface(s) and react to the window's menus/actions/...

\item FLSessionManager is a simple QObject. Its role is to be the compilation center and maintain the hierarchy of the current session. 

\end{itemize}

Many of the dialogs and internal structure classes are singletons to share their information with one shared access point. 

%%%%%%%%%%%%%%%%%FAUSTLIVE APP%%%%%%%%%%%%%%%%%%%
\section{FLApp}
 
FLApp reimplements QApplication. For that matter, it contains the main event loop, where all events from the window system and other sources are processed and dispatched. It also handles the application's initialization (some singletons have to be initialized by FLApp) and finalization.

\subsection{Menus}

The menus are handled differently, depending on the platform. \\
On OSX, the menu of the application appears in the system external menu-bar. Depending on the front window, the specific menus will show. \\
On Windows and Linux, each window of the application has its own menu-bar. There is no general menu-bar. That is why, when the last window is closed, the application quits. \\

While some actions are specific to the windows (edit, export, ...), others  are to be treated by the application (new, open, ...). The application-related menus and actions have to be created by the application to be connected to its SLOT. 

So, FLApp contains the following functions, for menu creation :
\begin{itemize}
\item create\_FileMenu() : QMenu* 
\item create\_ExampleMenu() : QMenu*
\item create\_RecentFileMenu() : QMenu*
\item create\_NavigateMenu() : QMenu*
\item create\_HelpMenu() : QMenu*
\end{itemize}

In order to appear in the window menu-bar, a list of menus is passed to the window when it is created.

\subsection{Create FLWindow}

To create a new FLWindow, the application has to choose two things
- The index of the window (the smallest not currently used)
- The position (depending on the index)

\subsection{Menus and Dialogs}

Help Dialog


\subsubsection{}
%%%%%%%%%%%%%%%%%WINDOW%%%%%%%%%%%%%%%%%
\section{FLWindow}



%%%%%%%%%%%%%%%%%SESSION MANAGER%%%%%%%%%%%%%%%%%
\section{FLSessionManager}

FLSessionManager is a singleton.\\

The role of FLSessionManager is to be the link with libfaust and libfaustremote, to compile the DSPs. Moreover, it has the function to maintain the hierarchy of the current session and be able to save/recall sessions and snapshots. 

\subsection{Current Session Hierarchy}

The current session is composed of : 
\begin{itemize}
\item Settings.ini : file containing the saved settings as described in FLSettings
\item Examples : folder containing a copy of the example files of the faust distribution
\item Libs : folder containing a copy of the libraries of the faust distribution
\item Windows : folder containing the window-specific folders FLW-i, containing :
	\begin{itemize}
		\item Settings.ini : the window specific settings as described in FLWinSettings
		\item Graphics.rc : file saving the graphical parameters of the last DSP contained in the window
		\item Connections.jc : file saving the last known Jack connections of the window
		\item SHAKey.dsp* : copy of the faust code of the last DSP contained in the window (in case the original file is deleted or modified outside of FaustLive execution)
	\end{itemize}
\item SHAFolder : folder containing the DSP-specific folders, containing : 
	\begin{itemize}
		\item SHAKey* : LLVM intermediate representation of the DSP, to accelerate compilation when the same DSP is reused.
		\item SHAKey.dsp*: copy of the Faust code corresponding to this SHAKey
		\item SHAKey-svg* : folder containing the svg diagram resources
	\end{itemize}
\end{itemize}

*To establish a unique link between a DSP and its saving files, the SHA-1 hash function is used. This SHAKey is calculated from the faust code before compilation and its compilation options. That way, one code, compiled with different options is always saved. 

\subsection{DSP compilation}

To compile a DSP, there are two steps :
\begin{itemize}
\item create a factory (builds the protoype of a the DSP class)
\item create an instance of the factory (equivalent of a 'new class" in C++)
\end{itemize}

Because FaustLive enables remote processing, the factories and instances it creates can whether be local (llvm\_dsp\_factory / llvm-dsp ) through libfaust or remote (remote\_dsp\_factory / remote-dsp) through libfaustremote. \\

The goal of FLSession Manager is to be the only class that deals with remote\_dsp\_factory, llvm\_dsp\_factory, remote-dsp, llvm-dsp, ...

The classes that will need compilation will only receive a pointer to a dsp, without knowing its type. \\

Still, the two steps cannot be united in the same function, because some audio initialization is needed between the two steps (for the remote case where the sample rate and buffer size are needed to create the instance and only available once the factory is created...).

In conclusion, to create a dsp, there are those two functions :
\begin{itemize}
\item createFactory(const QString\& source, QString\& errorMsg, FLWinSettings* settings = NULL) \\ returns QPair<QString, void*> ;
\item createDSP(QPair<QString, void*> factorySetts, const QString\& source, QString\& errorMsg, FLWinSettings* settings = NULL, RemoteDSPErrorCallback error\_callback = NULL, void* error\_callback\_arg = NULL) \\ returns dsp*;
\end{itemize}

\subsubsection{create Factory}

Depending on the machine name, 

\subsubsection{create Instance}

\subsection{Session/Snapshot restoration}

%%%%%%%%%%%%%%%%%SETTING STRUCTURE%%%%%%%%%%%%%%%%
\section{Setting Management}

%%%%%%%%%%%%%%%%%GENERAL SETTINGS%%%%%%%%%%%%%%%%%
\subsection{FLSettings}

FLSettings is a singleton. 
To save settings, the class FLSettings reimplements QSettings. A hierarchy, presented {Figure \ref{fig:FLSettings}, allows us to access the settings easily. \\

The setting file is saved at the root of the current session (/Users/you/.FaustLiveCurrentSession-version).
 
\begin{figure}[!h]
\begin{center}
\includegraphics[width=\columnwidth]{images/FLSettings}
\caption{FLSettings structure}
\label{fig:FLSettings}
\end{center}
\end{figure}
 
For example, the value is accessible like this :\\
\textit{int httpPort = FLSettings::\_Instance()->value("General/Network/HttpDropPort", defaultValue);}

%%%%%%%%%%%%%%%%%WINDOW SETTINGS%%%%%%%%%%%%%%%%%
\subsection{FLWinSettings}

FLWinSettings reimplements QSettings. But, this class is not a singleton, each FLWindow is associated to a FLWinSettings. 

\begin{figure}[!h]
\begin{center}
\includegraphics[width=\columnwidth]{images/FLWinSettings}
\caption{FLWinSettings structure}
\label{fig:FLWinSettings}
\end{center}
\end{figure}


For example, the value is accesible like this :\\
\textit{int oscInPort = fSettings->value("Osc/InPort", defaultValue);} \\

 *** The added feature of FLWinSettings, compared to QSettings, is to synchronize three parameters of the window with the general settings. That way, Name, SHA and Path are also accessible from the general settings. This feature is really usefull for snaspshot and session restoration, to have a global vision of the existing windows.

%%%%%%%%%%%%%%%%%AUDIO STRUCTURE%%%%%%%%%%%%%%%%%
\section{Audio}

\subsection{Audio drivers used by FaustLive}
 
Depending on the operating system and the compiling options, it is possible to embed different audio architectures in FaustLive.
Default drivers are :
\begin{itemize}
\item Coreaudio on OSX
\item Jack on Linux
\item Portaudio on Windows
\end{itemize}

Then Jack, NetJack and PortAudio can be added with make options : JACK=1 NETJACK=1 PORTAUDIO=1.

\subsection{Code Organisation}

The general structure of the code is based on the "abstract factory" pattern. That way, the class "AudioCreator" is the only class knowing which type of driver is used, creating the driver-specific factory.  \\

The abstract factory contains the following pure virtual functions :
\begin{itemize}
\item createAudioSettings(QGroupBox* parent)
\item createAudioManager(AudioShutDownCallaback, void* arg)
\end{itemize}

Then each audio driver has its own set of classes :
\begin{itemize}
\item audioFactory : creates the driver-specific elements (audioSettings and audioManager)
\item audioSettings : contains the settings needed by the driver and their graphical representation
\item audioFader : mixes the audio and crossfade features
\item audioManager : manipulates the audio faders and manage their crossfades 
\end{itemize}

\subsection{Crossfade implementation}

Some basic functions are common to all implementations and are divided into two classes :
\begin{itemize}
\item AudioFader\_Interface : containing the basic instructions needed by the client to launch a crossfade and know when it stopped. 
\item AudioFader\_Implementation : containing the calculation functions of the crossfade.
\end{itemize}

In order to add the crossfade feature to the audio clients, a reimplementation of the audio classes was made.
The doble inheritance of these "audioFader" permits to mix the audio features and the crossfade features. \\
The separation between interface and implementation sometimes had to be made because some audio classes (like coreaudio-dsp) already made the difference (coreaudio/TCoreAudioRenderer). 

\subsection{AudioManager}

There are two approach of the audio manager structure :
\begin{itemize}
\item the one managing one current client and fading the DSPs in one only client
\item the one managing one current client and creating a second one fading in to replace the current one
\end{itemize}

\subsection{How to add a new audio architecture}

To add a new type of driver audio in FaustLive, the first step is to implement the driver-specific set of classes :
\begin{itemize}
\item audioFactory
\item audioSettings
\item audioManager
\item audioFader
\end{itemize}

Then, some elements have to be added to the class "AudioCreator" : 
\begin{itemize}
\item add the new architecture to the enum "AudioArchitecture"
\item add a new item in the comboBox "fAudioArchitecture"
\item add a new case in createFactory
\end{itemize}

Finally, FaustLive.pro has to be modified (for each platform compatible with the new driver), in order to add the librairies (through conditional compilation or not).

%%%%%%%%%%%%%%%%%HTTP INTERFACES%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%OSC INTERFACES%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%REMOTE CONTROL%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%DISTRIBUTION STRUCTURE%%%%%%%%%%%%%%%%%
\section{Distribution Structure}

--> Build Folder with targets
--> 

\subsection{Create a new distribution}

--> 







\end{document}




